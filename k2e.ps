%!PS

% deconstructed writer for express pcb files

% reads kicad files, produces netlist, layout

% requires ghostscript min and max functions


% project notes

% are zones naturally ground planes
% fix keepout zones

% $DRAWSEGMENT is the true board outline

% arcs still need work


cleardictstack
/tfd (small.brd) def

%-------------------------------------------------------------------------

/KiCadDataFolderPfx (KiCad/myFiles/) def % change this to the full path where the 
						% converted files will be stored.  Must be full path from
						% top file directory, or files will be stored
						% in the conversion source directory. Directory must exist.


/verbose true def % return debug data on back channel

/render true def % render the board to the postscript page

/writefiles false def

/ddnetlist 1 def   % 0 do not echo netlist 1 echo netlist 2 write netlist to file


/DisplayFont /LucidaGrande def 
%/URWGothicL-Book def
%DisplayFont /AvanteGarde-Book /URWGothicL-Book def


% no user settings past this point

%######################################################################


/=$ {dup length 2 mul dup 60 idiv add 1 add string dup 
/ASCIIHexEncode filter 3 -1 roll 3 copy writestring 2 
index flushfile pop pop  closefile =} bind def

/$ {dup length 2 mul dup 60 idiv add 1 add string dup 
/ASCIIHexEncode filter 3 -1 roll 3 copy writestring 2 
index flushfile pop pop  closefile } bind def

%/dfa {pop} bind def  %
/dfa {{ exch =string cvs print (: ) print ==} forall} bind def

/makestring { 
	%verbose 2 gt {(<) print =$} if
	dup length string       % new string of right size
	dup /NullEncode filter      % make a file out of string
	2 index                 % array to stack top
    { 2 copy write pop }         % integers to string
	forall
    flushfile exch pop                   % clean up
} bind def

/strcat {
	dup length 2 index length add string
	2 index length 3 -1 roll 3 copy putinterval pop pop 
	0 3 -1 roll 3 copy putinterval pop pop 

} bind def


/Word_l$ <870000> def			% low first
/Long_l$ <8500000000> def		% low first

/Word$ <860000> def			% high first
/Long$ <8400000000> def		% high first

/qdbp {
% quick and dirty binary print
 16#10000 or 2 =string cvrs 1 16 getinterval
} bind def


/flushFlag false def  % only render on exit

/sheetCount 1 def 

% level2 date function
(%Calendar%) /IODevice resourcestatus {
	pop pop (%Calendar%) currentdevparams
	dup /Running get { /timedict exch def
		[ 
     	timedict /Year get 4 string cvs {} forall 45
     	timedict /Month get 2 string cvs {} forall 45
     	timedict /Day get 2 string cvs {} forall 32
     	timedict /Hour get 2 string cvs {} forall 58
     	timedict /Minute get 100 add 3 string cvs 1 2 getinterval {} forall 58
     	timedict /Second get 100 add 3 string cvs 1 2 getinterval {} forall
     	]
		makestring dup == /StartTime$ exch def
	}{
     (Clock/calendar is present but not running.\n) print
   } ifelse
 } {
   (No clock/calendar present.\n) print
 } ifelse


%quick and dirty proc for making a sort of timestamp
/TimeHashes 10 dict def
%quick and dirty proc for making a sort of timestamp
/TimeStamp {

(%Calendar%) currentdevparams begin
10 dict begin  % make a local dictionary for constants
/SEC_PER_HOUR 60 60 mul def
/SEC_PER_DAY SEC_PER_HOUR 24 mul def 
/SEC_IN_MONTH [0 2678400 5097600 7776000 10368000 13046400 15638400 18316800 20995200 23587200 26265600 28857600] def

Year 1970 sub 365.2425 mul SEC_PER_DAY mul cvi % approximate the number of seconds since 0 time
SEC_IN_MONTH Month 1 sub get cvi add  % add in the seconds to the first of the month
Day 1 sub SEC_PER_DAY mul cvi add % seconds to midnight the prior day
Hour SEC_PER_HOUR mul cvi add
Minute 60 mul cvi add
%	(->) print pstack (<-) =	
Second add 
%	(->) print pstack (<-) =	
cvi dup 16 8 string cvrs exch

end
{
	1 index cvn TimeHashes exch 2 copy known
	{
	%(y->) print pstack (<-) = flush
		get 1 add 
		cvi dup 16 8 string cvrs exch
		4 -2 roll pop pop %put
	
	
	%(y->) print pstack (<-) = flush
	}{
	%(n->) print pstack (<-) = flush
		3 -1 roll put exit
	%(n->) print pstack (<-) = flush
	}ifelse
} loop
end
} bind def
% functions for decoding the input stream

/invalid %(/\\:*?"<>|) 
<<47 95 92 95 58 95 42 95 63 95 34 95 60 95 62 95 124 95 >>
def


/quoteText {
	tf read {
	%dup ==
		% find first quote
		{
			34 eq {exit}if
		
		} loop
		[
			{
				tf read {
					dup 34 eq {pop exit} if
					invalid 1 index known {
						pop % ignore invalid chars 
					}if
				}{ exit }ifelse
			} loop
		] makestring
		%(->) print pstack (<-) = flush
	}{()}ifelse
	
} bind def

/isNumber << % >>
	/48 0
	/49	1
	/50	2
	/51	3
	/52	4
	/53	5
	/54	6
	/55	7
	/56 8
	/57 9
>> def

/putItem {
	10 dict begin
	/k exch def
	cvi /i exch def
	
	2 setobjectformat
	/ts 12 string def
	/of ts /NullEncode filter def
	of i 0 writeobject
	of flushfile
	ts 8 k getinterval
	end
} bind def

/linkParameters << % >
	/refcount 0 def
>> def 


/NewLink {
	/Object exch def
	% may want to devolve this	
	% to use <object>Type enumerators
	/next 0 def
	/group 0 def
	/parent 0 def
	
	linkParameters begin
		/refcount refcount 1 add def
		refcount
	end 
	/self exch def

} def

/LineWidthMap [ 0 10 12 15 20 25 30 40 50 60 80 100 120 150 8 7 200 250 6 ] def
% forward map	/traceThick LineWidthMap traceWidth get def

/textSizeFilter [38 40 45 50 60 70 80 90 100 110 125 150 175 200 225 250 300 350 400 500 ] def


% epcb hole size limit table
/drillLimit [ 
 0   14  20  25  29  33  35  40
 43  46  52  61  67  79  88  93
100 110 125 141 150 167 192 251 
] def

/revMapdrill [
 0  200	260	310 350 390 420 465
492 520	595	670 730	860 935	995
1065 1160 1319 1470	1570 1730 1990 2570
] def


/revRotate 	<< % >
	-360	0
	-270	3	
	-180	2	
	-90		1
	0		0
	90		1
	180		2
	270		3
	360		0
>> def

%back draw arcs
/ARC_ANGLE [ 360.0 300.0 210.0 180.0 90.0 -90.0 ] def

/ARC_SHAPE [[0 360.0] [120.0 60.0]  [165.0 15.0]  [180.1 359.9] [225.0 315.0] [270.0 0]] def

/K_ARC_DIRECTION [
%    360       300          210           180           0/45       90/0 
	[[0 360.0] [ 120.0 600] [165.0  15.0] [180.1 359.9] [225.0 315.0] [  0    90.0]] % 0
	[[0 360.0] [210.0 1500] [255.0 105.0] [270.1  89.9] [315.0  45.0] [ 90.0 180.0]] % 90
	[[0 360.0] [300.0 2400] [345.0 195.0] [  1   179.9] [ 45.0 135.0] [180.0 270.0]] % 180
	[[0 360.0] [ 30.0 3300] [ 75.0 285.0] [ 90.1 269.9] [135.0 225.0] [270.0   0  ]] % 270
] def


% anular ring copper limit 0.017

% hole clearance 0.021
% edge clearance 0.025


% kiCad layer mapping

% 0 Copper layer
% 1 to 14 Inner layers
% 15 Component layer

%Technical layers

%16 Copper side adhesive layer
%17 Component side adhesive layer
%18 Copper side Solder paste layer
%19 Component Solder paste layer


%20 Copper side Silk screen layer
%21 Component Silk screen layer

%22 Copper side Solder mask layer
%23 Component Solder mask layer
%24 Draw layer (Used for general drawings)
%25 Comment layer (Other layer used for general drawings)
%26 ECO1 layer (Other layer used for general drawings)
%27 ECO2 layer (Other layer used for general drawings)
%28 Edge layer. Items on Edge layer are seen on all layers
%29 Not yet used
%30 Not yet used
%31 Not yet used

/layerMap << % >>

	21 2 % top silk screen
	
	0 20 % bottom copper	
	15 10 % component

>> def





/parametersGeneral << % >
	/encoding /notdef
	/Units /notdef
	/LayerCount 0
	/EnabledLayers 0
	/Links 0
	/NoConn 0
	/Di 4 array 
	/Ndraw 0
	/Ntrack 0
	/Nzone 0
	/BoardThickness 0
	/Nmodule 0
	/Nnets 0
>> def

/parametersSetup << % >
	/InternalUnit 10 
	/Layers 0
	/Layer 0 %[0] Back signal
	%/Layer[15] Front signal
	/TrackWidth 0
	/TrackWidthHistory []
	
	/TrackClearence 0
	/ZoneClearence 0
	
	/Zone_45_Only 0
	
	/TrackMinWidth 0
	
	/DrawSegmWidth 0
	/EdgeSegmWidth 0
	
	/ViaSize 0
	/ViaDrill 0
	
	/ViaMinSize 0
	/ViaMinDrill 0
	/MicroViaSize 0
	/MicroViaDrill 0
	/MicroViasAllowed 0
	/MicroViaMinSize 0
	/MicroViaMinDrill 0
	
	/TextPcbWidth 0
	/TextPcbSize []
	
	/EdgeModWidth 0
	/TextModSize []
	/TextModWidth 100
	
	/PadSize []
	/PadDrill 0
	/Pad2MaskClearance 0
	
	/AuxiliaryAxisOrg []
	/VisibleElements -1
	/PcbPlotParams ()
>> def

/optionsPAD << % > 
	/STD {
		attribShape 2 eq {

		gsave
		
		233 255 div 150 255 div 122 255 div setrgbcolor
		x1 y1 padWidth 2 div 0 360 arc fill

		0 1 1 setrgbcolor
		x1 y1 drillLimit padDrillIdx 1 add get 17 add
		2 div 0 360 arc fill

		
		1 1 0 setrgbcolor
		x1 y1 drillLimit padDrillIdx 1 add get
		2 div 0 360 arc fill
		
		0 0 0 setrgbcolor
		x1 y1 padDrill 2 div 0 360 arc fill
	
		
		grestore
		} if

		attribShape 3 eq {

		gsave
		
		gsave
		233 255 div 150 255 div 122 255 div setrgbcolor
		x1 y1 translate
		padWidth neg 2 div padHeight neg 2 div padWidth padHeight rectfill
		grestore
		
		0 1 1 setrgbcolor
		x1 y1 drillLimit padDrillIdx 1 add get 17 add
		2 div 0 360 arc fill

		
		1 1 0 setrgbcolor
		x1 y1 drillLimit padDrillIdx 1 add get
		2 div 0 360 arc fill
		
		0 0 0 setrgbcolor
		x1 y1 padDrill 2 div 0 360 arc fill
	
		
		grestore
		} if

		
		
	} 

	/SMD {
		% need to check layer map for color
		
render {
		gsave
		
		x1 y1 translate
		
		verbose {
			(angle: ) print padAngle ==
			(layers: 0x) print padLayerMap 16 8 string cvrs =
		} if
		%(b: ) print padLayerMap 1 and ==
		
		%(c: ) print 
		
		padLayerMap 16#8000 and 0 ne {
		
			233 255 div 150 255 div 122 255 div setrgbcolor
		}{
			123 255 div 104 255 div 238 255 div setrgbcolor
		} ifelse
		
		%angle rotate
		padAngle rotate

		padWidth neg 2 div padHeight neg 2 div padWidth padHeight rectfill

		0 0 0 setrgbcolor
		0 setlinewidth

		padWidth neg 2 div 0 moveto padWidth  2 div 0 lineto stroke
		0 padHeight neg 2 div moveto 0 padHeight 2 div lineto stroke

		%	 -30 0 moveto 30 0 lineto stroke				% mark new origin
		%	 0 -30 moveto 0 30 lineto stroke
		
		newpath
		0 padHeight 2 div moveto
		-3 -7 rlineto
		6 0 rlineto
		closepath fill
		%-30 70 rlineto stroke

		grestore
} if	

	}
	dup /CONN exch
	
	/HOLE {

render {
	gsave
		0 1 1 setrgbcolor
		x1 y1 drillLimit padDrillIdx 1 add get 17 add
		
		/padWidth exch def
		/padHeight padWidth def
		
		%(Hole: ) print padWidth ==
		%padHeight ==
		
		padWidth 2 div 0 360 arc fill

		1 1 0 setrgbcolor
		x1 y1 drillLimit padDrillIdx 1 add get
		2 div 0 360 arc fill
	grestore
} if

	}
	dup /MECA exch 

>> def

/commandsPad << % >	
										
	/Sh {
		%Shape: <pad name> shape Xsize Ysize Xdelta Ydelta Orientation
		%"1" O 740 740 0 0 900
		quoteText /padIDTxt exch def

		tf token {/padShape exch def} if
		tf token {10 div /padWidth exch def} if
		tf token {10 div /padHeight exch def} if
		tf token {10 div /padXdelta exch def} if
		tf token {10 div /padYdelta exch def} if
		tf token {10 div /padAngle exch def} if
		%currentdict dfa

		% need to update the number of pads in the parent
		% dictionary

		% how to deal with pins what are not numbers		
		% specifically A and C or K on diodes
		
		currentdict end  
		/padCount padCount 1 add def
		begin 
		% we now return to our regularly scheduled dictionary
		
		% convert the pad here once
		padIDTxt length 0 gt {	
			padIDTxt cvx {exec} stopped {
			padCount
(# NAN: ") print padIDTxt print (" pad count: ) print dup ==
			}if
			% converted pin number is on stack
		}{
			padCount
(# empty pad name: ") print padIDTxt print (" pad count: ) print dup ==
		}ifelse
		/padIDNum exch def
%(pin number: ) print padIDNum ==
		
%(pad shape: ) print /padShape load ==		
		10 dict begin
		/C {2} def
		/R {4} def
		
		/O {2} def	% can special case these as buildups
		/T {2} def	% could do this as a built up pad 
		
		padShape 
		end
		/attribShape exch def

%(attribute shape: ) print attribShape ==


		
	} 

	/Dr {
		%Drill <Pad drill> Xoffset Yoffset (round hole)
		tf token {10 div /padDrill exch def} if
		[
			2 {
				tf token {10 div } if
			}repeat
			
		]
		/padOffset exch def
		
%		(drill size: ) print padDrill ==
		

		0 1 drillLimit length 2 sub {
			/padDrillIdx exch def
			
			padDrill 0 eq {exit} if
			
			padDrill drillLimit padDrillIdx get gt 
			padDrill drillLimit padDrillIdx 1 add get le  
			and {exit}if
	
		}for

%		(drill index: ) print padDrillIdx  ==
		
%		(drill map: ) print drillLimit padDrillIdx 1 add get ==

		
	}
	
	% or 
	%<Hole shape> <Pad drill.x> <Pad drill.y>
	/O {tf 72 string readline pop pop} 

	/At {
	%Attributs: <Pad type> N <layer mask>
	%STD N 00C0FFFF
		tf token {/padAttributs exch def} if

		tf token {pop} if % the N parameter

		tf 4 string readhexstring {
		Long$ 1 3 -1 roll putinterval 
		%(-> ) print pstack (<-) = flush
		Long$ cvx exec
		}{ 0 }ifelse

		/padLayerMap exch def
		
		10 dict begin

			/STD {
				% change shape from SMD to STD for square pads
				attribShape 4 eq {
					currentdict end
					/attribShape 3 def
					begin
				}if 
			
			100
			
			} def
			
			/SMD {

				padLayerMap 16#8001 and 16#8001 eq {
					100		
				}{
					padLayerMap 16#8000 and 0 eq {
			 			20 
					}{
						10 
					}ifelse
				}ifelse
			} def
			
			/CONN {100} def
			/HOLE {100} def
			/MECA {100} def
			
			padAttributs
		end
		/padLayers exch def
		
%		(pad layer attributes: ) print padLayers ==

	}

	/Ne {
	%Net reference of the pad: <netnumber> <net name>
	%27 "MISO"
		tf token {
			/netIdx exch def
		} if
		quoteText /netTxt exch def

	}
	
	/.SolderMask {tf 72 string readline pop pop}
	dup /.SolderPaste exch
	
	/Po { %-1000 500

			tf token {
				10 div /padX exch def
			}if

			tf token {
				10 div /padY exch def
			}if

			padX padY moduleMatrix itransform 
			/y1 exch def /x1 exch def
			


	}

	/$EndPAD {
		 % render or translate Pad dict here

		% need to fix to add detection of square pads
		% and round smt (bga) pads


		optionsPAD /padAttributs load 2 copy known {
			get exec
		}{
			pop pop
			/attribShape 1 def
render {
gsave
-30 0 moveto 30 0 lineto stroke				% mark new origin
0 -30 moveto 0 30 lineto stroke
grestore
}if
		}ifelse


		% pack attributes into word
		/var_2C attribShape revRotate padAngle get 4 bitshift or padLayers 6 bitshift or  def
				 
		% need to flag this pad as an edge in the corners table
		/edgeReverse 
		x1 cvi 10 string cvs
		(_) strcat 
		y1 cvi 10 string cvs 
		strcat cvn def

		CornerReverse edgeReverse 2 copy known {
(# edge overlap: ) print get ==
			% overlapping edges
			% can happen when a surface pad overlaps
			% a pad used as a via
			
			% currently we only track one marker per edge
		}{
verbose {(new edge: ) print self =string cvs print ( ) print edgeReverse ==} if
			self put  % mark edge as busy
					  % may have to deal with layers when SMT pads are
					  % used
		}ifelse
		
		self
		currentdict
		end
		Board 3 1 roll put	



		% layer interconnects need to relate to named Zone and 
		% the netlist reference 


		/tabs tabs 1 sub def		
		exit
		 			
	}



>> def

/commandsModule << % >
	/Po {
		%Po Xpos  Ypos  Orientation(0.1deg) Layer TimeStamp         Attribut1Attribut2
		%   41500 30855 900                 15    00000000 00000000 ~~
		
			tf token {
				10 div /centerX exch def
			}if

			tf token {
				10 div /centerY exch def
			}if

			tf token {
				10 div /angle exch def
			}if

			tf token {
				/layer exch def
			}if

			
			centerX centerY localMatrix itransform 
			/y1 exch def /x1 exch def
			
			1 1 1 setrgbcolor
			
			0 setlinewidth
			
			x1 neg y1 neg matrix translate
			angle matrix rotate 
			matrix concatmatrix
			/moduleMatrix exch def

			-70 0 moduleMatrix itransform moveto 70 0 moduleMatrix itransform lineto stroke				% mark new origin
			0 -100 moduleMatrix itransform moveto 0 100 moduleMatrix itransform lineto stroke

			0 100 moduleMatrix itransform moveto
			-30 30 moduleMatrix itransform lineto
			30 30 moduleMatrix itransform lineto
			0 100 moduleMatrix itransform lineto
			stroke
		
			tf 72 string readline { /attributes exch def} if
		
		%currentdict
		%dfa
		
	} 
	
	/Li	{	%library name
		% use this for a part name if the comment description
		% is not in the module name
		tf 72 string readline {
verbose {(library part name: ) print }if
			[ exch 
				{invalid 1 index known {pop 95}if} forall
			] makestring 
verbose {dup  ==} if
			/command load exch def
		}if
	} 
	
	/Sc	{tf 72 string readline pop pop} %Timestamp
	dup /Op	exch 						%rotation cost factors
	dup /Kw exch						% keyword

	/Cd {	%comment description
		% this is the best field to store as the part name
		% in the file
		tf 72 string readline {
verbose {(comment description name: ) print} if
			[ exch 
				{invalid 1 index known {pop 95}if} forall
			] makestring 
verbose {dup ==}if
			/command load exch def
		}if 
	} 						

	% field descriptors
	 /T0 {fieldParameters}	% this is the part ref 
	dup /T1	exch 			% part value, not to be confused with the part name
	dup /T2	exch 			% typically extra comment description

	/DS	{ % draw segment
		%DS Xstart Ystart Xend Yend Width Layer
		/segmentCount segmentCount 1 add def
	
		10 dict begin
						
		tf token {
			10 div /xStart exch def
		}if
		 
		tf token {
			10 div /yStart exch def
		}if
		 
		tf token {
			10 div /xEnd exch def
		}if
		 
		tf token {
			10 div /yEnd exch def
		}if 
		
		tf token {
			10 div /lineThickness exch def
			% may have to manage valid line widths
		}if 
		
		tf token {
			/lineLayer exch def
		}if 

		%(segment dict:) print currentdict dfa

		lineLayer 21 eq {
			%(silk module) =	
			localModule begin
			/linkCount linkCount 1 add def
		
			linkCount
			end		
			/linkCount exch def % use this for pin number when pin number is text
						
			9 NewLink

			% update the local linked list
			linkCount 1 eq {
				localModule /firstLink self put
				%(new root: ) print self ==
			}{
				% simple method without search links are added in order
				% to the prior reference
				self
				Board self 1 sub get begin
				/next exch def
				%( n: ) print next =string cvs print
				end
			} ifelse
			
			% must be layer
			%read1 (layer: )
	
			% start and end points
			%read3 (x1: )
			%read3 (y1: )
			xStart yStart moduleMatrix itransform 
			/y1 exch def /x1 exch def

			%read3 (x2: )
			%read3 (y2: )
			xEnd yEnd moduleMatrix itransform 
			/y2 exch def /x2 exch def
	
			% thickness
			%read3 (t: )
	
			self
			currentdict
			end % working temp dict
			Board 3 1 roll put
		}{
			end
		}ifelse

	} 
	
	/DC {
		 % draw circle
		 %DC <Xcentre> <Ycentre> <Xpoint> <Ypoint> <Width> <Layer>
verbose {(drawing circle: ) =} if
		10 dict begin
						
		tf token {
			10 div /Xcentre exch def
		}if
		 
		tf token {
			10 div /Ycentre exch def
		}if
		 
		tf token {
			10 div /Xpoint exch def
		}if
		 
		tf token {
			10 div /Ypoint exch def
		}if 
		
		tf token {
			10 div /lineThickness exch def
			% may have to manage valid line widths
		}if 
		
		tf token {
			/lineLayer exch def
		}if 
		%lineLayer 21 eq 
		layerMap lineLayer known {
			%(silk module) =	
			localModule begin
			/linkCount linkCount 1 add def
		
			linkCount
			end		
			/linkCount exch def % use this for pin number when pin number is text
						
			10 NewLink

			% update the local linked list
			linkCount 1 eq {
				localModule /firstLink self put
				%(new root: ) print self ==
			}{
				% simple method without search links are added in order
				% to the prior reference
				self
				Board self 1 sub get begin
				/next exch def
				%( n: ) print next =string cvs print
				end
			} ifelse


		%	10: arc
		%	key1: attributes
		%		shape always 1 for circle
			/shape 1 def
		%		dir rotation is 1 for circle 
			/arcrotation 1 def 
		%	key3: positionX
		%	key3: positionY
			Xcentre Ycentre moduleMatrix itransform 
			/y1 exch def /x1 exch def

		%	key3: radius
		
		%d = SQRT((x2-x1)2+(y2-y1)2) 
		/radius
		Xpoint Xcentre sub dup mul
		Ypoint Ycentre sub dup mul
		add sqrt def
				
render {
		%	key3: linewith
		1 255 215 div 0 setrgbcolor		
		%	key1: layer
		lineThickness setlinewidth
			
		Xpoint Ypoint moduleMatrix itransform moveto 
		x1 y1 radius 0 360 arc stroke
}if

			self
			currentdict
			end % working temp dict
			Board 3 1 roll put

		}{
			end
		}ifelse
	
	}
	/DA	{
		 % draw arc 
		 %DC <Xcentre> <Ycentre> <Xpoint> <Ypoint>  <angle> <width> <layer>

verbose {(\ndrawing arc: ) =} if
		10 dict begin
						
		tf token {
			10 div /Xcentre exch def
		}if
		 
		tf token {
			10 div /Ycentre exch def
		}if
		 
		tf token {
			10 div /Xpoint exch def
		}if
		 
		tf token {
			10 div /Ypoint exch def
		}if 

		tf token {
			10 div /arcangle exch def
		}if 
	
		tf token {
			10 div /lineThickness exch def
			% may have to manage valid line widths
		}if 
		
		tf token {
			/lineLayer exch def
		}if 
		%lineLayer 21 eq 
		layerMap lineLayer known {
			%(silk module) =	
			localModule begin
			/linkCount linkCount 1 add def
		
			linkCount
			end		
			/linkCount exch def % use this for pin number when pin number is text
						
			10 NewLink

			% update the local linked list
			linkCount 1 eq {
				localModule /firstLink self put
				%(new root: ) print self ==
			}{
				% simple method without search links are added in order
				% to the prior reference
				self
				Board self 1 sub get begin
				/next exch def
				%( n: ) print next =string cvs print
				end
			} ifelse


		%	10: arc
		%	key1: attributes
		%		shape 
		% limit to [360 300 210 180 90 or 90 corner]

		arcangle abs 90 le {
			
			/shape 5 def
		}
		{
			arcangle abs 180 le {/shape 4 def}
			{
				arcangle abs 210 le {/shape 3 def}
				{
					arcangle abs 300 le {/shape 3 def}
					{
						/shape 1 def
					} ifelse
				} ifelse
			} ifelse
		}ifelse

		%		dir rotation is [0 90 180 270]
		
		% gets complex as there is need to template map the
		% arcs to the limits above
		
		%	key3: positionX
		%	key3: positionY
			Xcentre Ycentre moduleMatrix itransform 
			/y1 exch def /x1 exch def
verbose {(center: ) print Xcentre Ycentre exch =string cvs print (, ) print == } if

		%	key3: radius
		%d = SQRT((x2-x1)2+(y2-y1)2) 
		/radius
		Xpoint Xcentre sub dup mul
		Ypoint Ycentre sub dup mul
		add sqrt def
verbose {(radius: ) print radius ==}if
	
		%	key3: linewith
		lineThickness setlinewidth

		%	key1: layer
		%1 255 215 div 0 setrgbcolor		

		/arcTangent Ypoint Ycentre sub  Xpoint Xcentre sub atan def
verbose {
(point 1: ) print Xpoint Ypoint exch =string cvs print (, ) print ==
(angle: ) print angle ==
(atan of point 1: ) print  arcTangent ==
} if	
		% remove part rotation from angle
		/refangle  arcTangent angle add def %
		{
			refangle 360 lt {exit} if
			/refangle refangle 360 sub def
		}loop
		
verbose {
(reference angle : ) print refangle ==
(shape: ) print shape ==
} if
		% adjust for corners
		shape 5 eq {
			<< 0 3 90 4 180 1 270 2 >>
			refangle abs cvi 2 copy known {
				get /arcrotation exch def
				/shape 6 def
				arcangle 0 lt {
					/arcrotation arcrotation 1 sub def
					arcrotation 0 eq {/arcrotation 4 def}if
				}if
			}{
				pop pop
				/arcrotation 1 def
			}ifelse
		}{
			refangle abs 90 lt {/arcrotation 2 def}
			{
				refangle abs 180 lt {/arcrotation 2 def}
				{
					refangle abs 270 lt {/arcrotation 3 def}
					{
						refangle abs 360 lt {/arcrotation 4 def}
						{
							/arcrotation 1 def
						} ifelse
					} ifelse
				} ifelse
			}ifelse
		}ifelse

% fix for negative arcs
		arcangle cvi -180 eq {
			/arcrotation arcrotation 2 sub def
			arcrotation 0 le {
				/arcrotation arcrotation 4 add def
			}if
			
		}if 

verbose {(arcrotation: ) print arcrotation ==}if	

		Xpoint Ypoint moduleMatrix itransform moveto 
		gsave
		% CTM affects on display are not tracked in local matrix
		x1 y1 translate refangle angle add rotate  

		0 0 radius 0 arcangle
		 arc stroke

		grestore

		1 0 255 215 div  setrgbcolor		

		x1 y1 moveto
		Xpoint Ypoint moduleMatrix itransform  
		lineto stroke


		0 1 0 setrgbcolor
		lineThickness .5 mul setlinewidth

		x1 y1 moveto
		Xcentre radius add Ycentre moduleMatrix itransform  
		lineto stroke


		1 1 1 setrgbcolor
		lineThickness 1.2 mul setlinewidth
		
	
			

render not {
		gsave
		lineThickness setlinewidth
		1 255 215 div 0 setrgbcolor		
	
		x1 y1 radius 
		K_ARC_DIRECTION arcrotation 1 sub get shape 1 sub get {} forall
		arc stroke
		grestore
} if


			self
			currentdict
			end % working temp dict
			Board 3 1 roll put

		}{
			end
		}ifelse
	
	} 
	
	/DP	{
	% draw polygon
	%DP 0 0 0 0 corners_count width layer
		/this_poly 10 dict def
		
		this_poly begin
						
		tf token {
			/Z1 exch def
		}if
		 
		tf token {
			/Z2 exch def
		}if
		 
		tf token {
			/Z3 exch def
		}if
		 
		tf token {
			/Z4 exch def
		}if 

		tf token {
			/segments exch def
		}if 
	
		tf token {
			10 div /penWidth exch def
			% may have to manage valid line widths
		}if 
		
		tf token {
			/zoneLayer exch def
		}if 
		
		/polyLineCount 0 def

		/keepout 1 def
				
		end 
	
	}
	  
	/Dl	{
	 % draw line (polygon)
	 %Dl corner_posx corner_posy
	 	this_poly begin

		/polyLineCount polyLineCount 1 add def
		/segmentCount segmentCount 1 add def
	%x y endflag
	
		segmentCount 
		[
		tf token {10 div}if
		tf token {10 div}if
		moduleMatrix itransform 
	
		] def
		
		% make Zone
		
		% special case 4 and 5 corner poly's as these
		% can be filled rects on any layer
		
		% single segments are lines
		
		% poly's on silk layer are not allowed
		% convert these to outlines
		
		% poly's on pad components are not allowed
		segmentCount segments  ge {
			% create a new zone for keepout (cutout) area
		    % inherit parameters
	zoneLayer 21 eq {
(silk zone1: ) = 
currentdict dfa
(-----------------) =
	}if
			% close this dict


			localModule begin
			/linkCount linkCount 1 add def
		
			linkCount
			end		
			/linkCount exch def % use this for pin number when pin number is text
						
			11 NewLink

			% update the local linked list
			linkCount 1 eq {
				localModule /firstLink self put
				%(new root: ) print self ==
			}{
				% simple method without search links are added in order
				% to the prior reference
				self
				Board self 1 sub get begin
				/next exch def
				%( n: ) print next =string cvs print
				end
			} ifelse

			self
			currentdict
%(closing old zone ) =
%currentdict dfa
%(--------------) =
			end % working temp dict
			Board 3 1 roll put

		}{
			end
		}ifelse
	}


	/At	{tf 72 string readline pop pop} % attributes  
	dup /.SolderMask exch
	dup /.SolderPaste exch

	/AR {tf 72 string readline pop pop}  %not documented

/$PAD {
		verbose {
			tabs {( ) print} repeat
			($PAD) =
		}if
		/tabs tabs 1 add def 
		descriptions /PAD get exec
	}
	
/$SHAPE3D {
		verbose {
			tabs {( ) print} repeat
			($SHAPE3D:) =
		}if
		/tabs tabs 1 add def 
		descriptions /SHAPE3D get exec
	}
	
/$EndMODULE {
	tf 72 string readline {

		verbose {
			tabs {( ) print} repeat
			(/$EndMODULE ref: ) print == flush
		}{
			pop 
		}ifelse	


		grestore

		padCount 1 lt {
%(group header: ) =
%currentdict dfa
%(----------) =
			% this is a group rather than a footprint or module
			
			T0 begin 
				7 NewLink
				% make field text static
				/staticText fText def
				% always on silk layer
				/this_layer 2 def
				% always visible
				/attrib_text attrib_text 16#FFF7 and def

			% update the local linked list
			linkCount 0 eq {
(new root: ) print self ==
				self
				dup
				currentdict
				end % working temp dict
				Board 3 1 roll put
				/firstLink exch put
				/linkCount linkCount 1 add def
				
			}{
verbose {
(next object: ) =
currentdict dfa
(++++++++++) =
}if
				% simple method without search links are added in order
				% to the prior reference
				self
				Board self 1 sub get begin
				/next exch def
( n: ) print next == %=string cvs print
				end
				self
				currentdict
				end % working temp dict
				Board 3 1 roll put
			} ifelse
			
			T1 begin 
				7 NewLink
				% make field text static
				/staticText fText def
				% always on silk layer
				/this_layer 2 def
				% always visible
				/attrib_text attrib_text 16#FFF7 and def

			% update the local linked list
			linkCount 0 eq {
(new root1: ) print self ==
				self
				dup
				currentdict
				end % working temp dict
				Board 3 1 roll put
				/firstLink exch put
				/linkCount linkCount 1 add def
			}{
verbose {
(next object1: ) =
currentdict dfa
(++++++++++) =
}if
				% simple method without search links are added in order
				% to the prior reference
				self
				Board self 1 sub get begin
				/next exch def
( n1: ) print next == %=string cvs print
				end
				self
				currentdict
				end % working temp dict
				Board 3 1 roll put

			} ifelse

			%T2 sometimes contains comment text

			1 NewLink
			/key1_type 1 def %title block
			/localGroup self def

			
			self
			currentdict
			end % working temp dict
			Board 3 1 roll put
		
			localModule begin
verbose {
(group module: ) print localGroup == % =string cvs print
currentdict dfa
(----+++-----) =
} if
		}{
			1 NewLink
			/key1_type 4 def

			/localGroup self def

			partIDs dup begin
			/partIDsTableLength partIDsTableLength 1 add def
			partIDsTableLength
			end
			self put
		
		}ifelse
		
		
		{firstLink}stopped {
			(# root link not found: ) print self ==
			%currentdict dfa flush stop
			T0 /fText get ==
			T1 /fText get ==
			
			% write the header anyway could be a null group
			% as these seem to exist
			/firstLink 0 def


			self
			currentdict
			end % working temp dict
			Board 3 1 roll put
		
		}{
			/listLink exch def 		
			{
				localGroup
				Board listLink get begin
				/group exch def
				%(s: ) print self =string cvs print
				%( c: ) print Object =string cvs print
				%( g: ) print group =string cvs print
				%( n: ) print next ==
				
				next
				end
				/listLink exch def
				listLink 0 eq{exit} if
			} loop

	
			% dump the module group here. we should have all the parameters
			
			% silkscreen drawing commands
			% update group links
			
			% pad drawing commands
			% update group links
			
			% detail netlist edge connections
			
			self
			currentdict
			end % working temp dict
			Board 3 1 roll put
			
		}ifelse

	}{/eof true def exit }  ifelse 
	/tabs tabs 1 sub def
	
	% process module
	
	
	exit
	}


	
>> def

/commandsDraw << % >

	%Po <shape> <Xstart> <Ystart> <Xend> <Yend> <width> 
	/Po {

		tf token {
			/shape exch def 
		}if

		tf token {
			10 div /Xstart exch def 
		}if

		tf token {
			10 div /Ystart exch def
		}if

		% define point in board space
		Xstart Ystart localMatrix itransform /y1 exch def /x1 exch def

		tf token {
			10 div /Xend exch def
		}if
		
		tf token {
			10 div /Yend exch def
		}if

		Xend Yend localMatrix itransform /y2 exch def /x2 exch def

		tf token {
			10 div /lineThickness exch def   % with of text drawing pen
		}if		
			
	}

	%De <layer> < 1 == normal | 0 == mirrored> timestamp <Normal | italic>
	/De {
		tf token {
			/drawLayer exch def
		}if

		tf token {
			/drawType exch def
		}if

		tf token {
			10 div /drawAngle exch def
		}if

		tf token {
			/timestamp exch def
		}if

		tf token {
			/status exch def
		}if

	}

	/$EndDRAWSEGMENT {


		gsave
		
		drawLayer 28 eq {/drawLayer 21 def} if  % move edges to silk
		
		shape 0 eq {
			% simple line object
			%		-- unless it is a trace or a board edge
		
			drawLayer 21 eq {
			
				9 NewLink
				self
				currentdict
				%end % working temp dict
				Board 3 1 roll put
				

render {
	1 1 1 setrgbcolor
	lineThickness setlinewidth
	x1 y1 moveto x2 y2 lineto stroke
} if
			
			}{
				drawLayer 0 eq drawLayer 15 eq or {
					% line is a trace
				
				}if
			
			}ifelse
		
		
		}if
		
				
		shape 1 eq shape 3 eq or {
			% simple circle, can be on any layer
($EndDRAWSEGMENT: ) =
currentdict dfa
(----circle----) =
		
		}if
		
		shape 2 eq {
			% complex arc can be on any layer
($EndDRAWSEGMENT: ) =
currentdict dfa
(----arc----) =
		
		}if
		

		
	
		grestore
		end
		exit
	}

>> def

/commandsText << % >

	%Te "<string>" -- with quotes
	/Te {
	
		quoteText /staticText exch def 
	
	}
	
	%Po <Xstart> <Ystart> <Xsize> <Ysize> <Width> <rotation>
	/Po {

		tf token {
			10 div /Xstart exch def 
		}if

		tf token {
			10 div /Ystart exch def
		}if

		% define point in board space
		Xstart Ystart localMatrix itransform /yc exch def /xc exch def

		tf token {
			10 div /Xsize exch def
		}if
		
		tf token {
			10 div /Ysize exch def
		}if

		tf token {
			10 div /penWidth exch def   % with of text drawing pen
		}if

		tf token {
			10 div /textRotation exch def
		}if
		
			
	}

	%De <layer> < 1 == normal | 0 == mirrored> timestamp <Normal | italic>
	/De {
		tf token {
			/textLayer exch def
		}if

		tf token {
			/textMirror exch def
		}if

		tf token {
			/timestamp exch def
		}if

		tf token {
			/textStyle exch def
		}if

		tf token {
			/justify exch def
		}if

	}

/$EndTEXTPCB {
verbose {(preload text dump: ) =}if

(raw text size: ) print Ysize =string cvs print ( ") print
staticText print
		
		0 1 textSizeFilter length 2 sub {
		/textSizeLimit exch def
		
		Ysize 38 lt {/textSizeLimit textSizeLimit 1 sub def exit} if
		
		Ysize textSizeFilter textSizeLimit get gt 
		Ysize textSizeFilter textSizeLimit 1 add get le  
		and {exit}if
	
		}for
		/Ysize textSizeFilter textSizeLimit 1 add get def

verbose  not {
	(" filtered text size: ) print Ysize ==
}if

		
		revRotate textRotation cvi 2 copy known {
			get 1 add
		}{
			pop pop 1
		}ifelse
		/attrib_dir exch def
		
		/attrib_text 
			attrib_dir 16#07 and
			Ysize cvi 4 bitshift 
			or
		def 

verbose {
attrib_text qdbp 
% split it out
dup 0 12 getinterval print ( ) print
dup 12 1 getinterval print ( ) print
%dup 13 1 getinterval print ( ) print
13 3 getinterval print (b TextAttributes) =

(backcheck attributes: ) print		
attrib_text -4 bitshift =string cvs print ( ) print
attrib_text 16#07 and ==
} if

 %lineWidthMap
	
		
		%Virtual space for scaling font
		gsave
		newpath
		DisplayFont findfont Ysize scalefont setfont
		0 0 moveto (M) true charpath pathbbox
		3 -1 roll sub 
		Ysize exch div Ysize mul /Yscale exch def 
		exch sub Xsize exch div Xsize mul 
		/Xscale exch def
		%pop pop
		
%(Mw: ) print
%		(M) stringwidth pop
% ==
%		Xsize exch div Xsize mul /Xscale exch def

		% define center first this is the default
		/textOffset 
		%staticText true charpath pathbbox 
		%pop exch pop sub 2 div  
		staticText length Xsize mul 2 div neg
		def
		
		
		%/Yscale Ysize def /Xscale Xsize def

		<< % >
			/L {/textOffset 0 def} 
			
			/R {
					/textOffset textOffset 2 mul def
				}
		>>
		/justify load 2 copy known {
			get exec
		}{
			pop pop
		}ifelse

		grestore

		% end of virtual space

	 	textRotation matrix rotate % file rotation

		xc yc matrix translate 
			 	
	 	matrix concatmatrix
	 	
	 	textRotation cvi abs 90 eq
	 	textRotation cvi abs 270 eq or {
	 		Ysize 2 div neg textOffset matrix translate
	 	}{
			textRotation cvi abs 0 eq
			textRotation cvi abs 180 eq or 
			textRotation cvi abs 360 eq or {
				textOffset Ysize 2 div neg matrix translate
		 	}{
		 		matrix
	 		}ifelse
	 	}ifelse
	 	
	 	matrix concatmatrix /textMatrix exch def

		0 0 textMatrix transform /y1 exch def /x1 exch def

verbose {
currentdict dfa
(---) =
	 	
(textMatrix: ) print  textMatrix ==
(\n) print
} if

render {
gsave
	
	DisplayFont %attrib_size 1.3 mul selectfont % rotate text context
	findfont 
	%[Yscale  0 0 2 index neg 0 4 index] 
	[Xscale 0 0 Yscale neg 0 Yscale]
	textRotation neg matrix rotate
	matrix concatmatrix
	%TX_DIRECTION  attrib_dir get matrix concatmatrix
	makefont setfont

verbose {currentfont /FontBBox get ==} if
	
			
	0 .3 .9 setrgbcolor
	penWidth setlinewidth
	
	xc 50 sub yc moveto xc 50 add yc lineto stroke
	xc yc 50 sub moveto xc yc 50 add lineto stroke

	gsave
	%x1 y1 translate % file translation
	0 0 textMatrix transform translate
			
	/Xpoint 0 def 
	staticText {
		Xpoint Ysize 2 div neg moveto ( ) dup 0 4 -1 roll put show
		Xpoint 0  Xsize Ysize rectstroke
		/Xpoint Xpoint Xsize add def
	} forall
	grestore	

	.9 .7 0 setrgbcolor
	penWidth setlinewidth
	
	
	-25 0 textMatrix transform moveto 25 0 textMatrix transform  lineto stroke
	0 -25 textMatrix transform moveto 0 25 textMatrix transform  lineto stroke
	
	1 1 1 setrgbcolor
	
	0 0 textMatrix transform moveto
	%0 0 moveto 
	staticText show
grestore
}if 

	layerMap textLayer 2 copy known {
		get
		/this_layer exch def

		7 NewLink	
		self
		currentdict
		end % working temp dict
		Board 3 1 roll put

	}{
		% ignore other text 
		pop pop
		end
	}ifelse

	
	exit
}	
	
>> def


/AddDefaultVia {
	% add a via to the object list
	% this version adds the default Via
	% this can be extended to check for negative drill size
	% a positive drill size can be used for custom via
	% sizes if matched to closest allowable drill


	/padLayers 100 def	% vias are always through
		
	/var_2C % 6401
	1 %attribShape 
	0 %padAngle
	4 bitshift or 
	padLayers %padLayers
	6 bitshift or def

	padDrill 20 lt {
		% use a default pad
		%key2: padWidth
		/padWidth parametersSetup /ViaSize get 10 div  def
		%key2: padHeight
		/padHeight padWidth def
		%key2: drill index (table of 24 drill sizes)
		/padDrill parametersSetup /ViaDrill get 10 div def

	} if

	0 1 drillLimit length 2 sub {
		/padDrillIdx exch def
		
		padDrill 0 eq {exit} if
		
		padDrill drillLimit padDrillIdx get gt 
		padDrill drillLimit padDrillIdx 1 add get le  
		and {exit}if

	}for
	
	% check for legal pad size adjust if necessary
	padWidth drillLimit padDrillIdx 1 add get 17 add lt {
			/padWidth drillLimit padDrillIdx 1 add get 17 add def
			/padHeight padWidth def
	}if

	/interconnect 0 def
	
verbose {
(adjusted via parameters: ) =
(padWidth: ) print padWidth ==
(padDrill: ) print drillLimit padDrillIdx 1 add get =string cvs print ( idx: ) print
padDrillIdx ==
} if
	%key2: pin number
	/padIDTxt (0) def
	/padIDNum 0 def
	%key1: layer interconnect attributes
/currentrender render def
/render false def
render {
		gsave
		
		233 255 div 150 255 div 122 255 div setrgbcolor
		x1 y1 padWidth 2 div 0 360 arc fill

		0 1 1 setrgbcolor
		x1 y1 drillLimit padDrillIdx 1 add get 17 add
		2 div 0 360 arc fill

		
		1 1 0 setrgbcolor
		x1 y1 drillLimit padDrillIdx 1 add get
		2 div 0 360 arc fill
		
		0 0 0 setrgbcolor
		x1 y1 padDrill 2 div 0 360 arc fill
	
		
		grestore

} if
/render currentrender def
	
} bind def

/commandsTrack << % >

	%Po <shape> <Xstart> <Ystart> <Xend> <Yend> <Width> <drill>
	/Po {
			/localTrack 10 dict def 
			
			localTrack begin  % working temp dict
			
			/linkCount 0 def  % modules are linked lists which are a forward reference
			/segmentCount 0 def
			
			Board /drawMatrix get /localMatrix exch def


		%Po Xpos  Ypos  Orientation(0.1deg) Layer TimeStamp         Attribut1Attribut2
		%   41500 30855 900                 15    00000000 00000000 ~~(Po) =		
			tf token {
				10 div /ViaShape exch def
			}if
			
			%expressPCB only supports through vias

			tf token {
				10 div /Xstart exch def 
			}if

			tf token {
				10 div /Ystart exch def
			}if

			% define point in board space
			Xstart Ystart localMatrix itransform /y1 exch def /x1 exch def

			tf token {
				10 div /Xend exch def
			}if
			
			tf token {
				10 div /Yend exch def
			}if
	
			% define point in board space
			Xend Yend localMatrix itransform /y2 exch def /x2 exch def


			tf token {
				10 div /padWidth exch def   % this is also trace with
			}if

			tf token {
				10 div /padDrill exch def   % negative for most traces
			}if								% can be used to set a custom drill
	}

	%De <layer> < 1 == via | 0 == track>  <netcode> <timestamp> <status>
	% De 0 0 1 0 0
	/De {
verbose {(De) =} if
			tf token {
				/traceLayer exch def
			}if
			% watch the pad layerspace
			% especially with traces
			/padLayers layerMap traceLayer get def
			

			tf token {
				/via exch def
			}if

			tf token {
				/netIdx exch def
			}if

			tf token {
				/timestamp exch def
			}if

			tf token {
				/status exch def
			}if

			/netTxt () def	% for completness we could look up net text from netlist
							% only useful for reports

verbose { 
(process track: ) =
currentdict dfa
(---------------) =
}if
			% it may be better to keep track corners in separate
			% layer lookups Xend


			0 1 12 { % LineWidthMap
				/traceIdx exch def
				
				padWidth 6 lt {/traceIdx 1 def exit} if % default to 10 mil trace
				
				% special case the additions
				padWidth 6 eq {/traceIdx 18 def exit} if
				padWidth 7 eq {/traceIdx 15 def exit} if
				padWidth 8 eq {/traceIdx 14 def exit} if
				
				padWidth 12 lt {/traceIdx 1 def exit} if
		
				padWidth 150 eq {/traceIdx 13 def exit} if
				padWidth 200 eq {/traceIdx 16 def exit} if
				padWidth 250 eq {/traceIdx 17 def exit} if
		
				padWidth 250 gt {/traceIdx 1 def exit} if % indicate something wrong
				
				padWidth LineWidthMap traceIdx get gt 
				padWidth LineWidthMap traceIdx 1 add get le  
				and {/traceIdx traceIdx 1 add def exit}if
		
			}for


			% create a simple text hash for reverse lookup
			/fromReverse 
			x1 cvi 10 string cvs
			(_) strcat 
			y1 cvi 10 string cvs 
			strcat cvn def

			/toReverse 
			x2 cvi 10 string cvs 
			(_) strcat
			y2 cvi 10 string cvs 
			strcat cvn def
%fromReverse ==
%toReverse ==
			via 1 eq {
verbose {(xVia: ) print via ==} if
				% if corner exists in the edge lookup
				% then we need to change it to
				% a via if it is already a corner
				CornerReverse fromReverse 2 copy known {
verbose {(corner exists: ) print fromReverse == } if
					get Board exch get 
					begin
verbose {
currentdict dfa
(-----p--------) =
}if
					Object 4 eq {
					
					% change it to a via
					/Object 3 def

						AddDefaultVia

					}{
verbose {
currentdict dfa				
(---------------) =
(->) print pstack (<-) =
}if
						% do we need to check if there is already
						% an object here? Most likely it will
						% be a surface pad with a via though it
					}ifelse
					end
				
				}{
					pop pop 
verbose {(new via: ) print via  =string cvs print ( ) print fromReverse == } if
					% create a new via and store it in edge
					10 dict begin
					3 NewLink
					% vias are pads
					% key2: Attributes 100: both layers
					% pad rotation 1
					% pad shape via

					AddDefaultVia

verbose {(via: ) print self ==} if
					localTrack /Xstart get
					localTrack /Ystart get 
					localMatrix itransform /y1 exch def /x1 exch def
	
					self
					currentdict
					end
					/via 2 index def
					CornerReverse fromReverse via put
					Board 3 1 roll put					
				}ifelse
			}{ 

				CornerReverse fromReverse 2 copy known {
					get /from exch def
verbose {(from found: ) print from  =string cvs print ( ) print fromReverse ==} if
					
					% debug draw
					Board from get begin
					x1 y1 moveto
					end
					
				}{
					pop pop
					% create a new corner
					10 dict begin
					4 NewLink

%localTrack dfa
					localTrack /Xstart get
					localTrack /Ystart get 
					localMatrix itransform /y1 exch def /x1 exch def
					
					x1 y1  moveto

					/padLayers layerMap traceLayer get def
	
					self
					currentdict
					end
					/from 2 index def
					CornerReverse fromReverse from put
					Board 3 1 roll put
					
verbose {(from defined: ) print from =string cvs print ( ) print fromReverse ==}if

				}ifelse

				CornerReverse toReverse 2 copy known {
					get /to exch def
verbose {(to found: ) print to  =string cvs print ( ) print toReverse ==} if

					% debug draw
					Board to get begin
					x1 y1 lineto
					end


				}{
					pop pop

					% create a new corner
					10 dict begin
					4 NewLink

					localTrack /Xend get
					localTrack /Yend get 
					localMatrix itransform /y1 exch def /x1 exch def
					
					 x1 y1 lineto

					/padLayers layerMap traceLayer get def
	
					self
					currentdict
					end
					/to 2 index def
					CornerReverse toReverse to put
					Board 3 1 roll put
verbose {(to defined: ) print to  =string cvs print ( ) print toReverse ==}if

				}ifelse
				
				
				5 NewLink
/currentrender render def
/render false def
render {				
				%gsave
parametersSetup /TrackClearence get 10 div 2 mul padWidth add setlinewidth
padLayers 2 eq padLayers 100 eq or {
	(# invalid layer !!!! )
	1 0 0 setrgbcolor
} if

padLayers 20 eq {
	0 1 0 setrgbcolor
}if

padLayers 10 eq {
	1 1 1 setrgbcolor
}if
				stroke
				%grestore
				
				%gsave
				0 0 0 setrgbcolor
					padWidth setlinewidth
				x1 y1 moveto x2 y2 lineto stroke
				%stroke
				%grestore

}if 
/render currentrender def
				
				self
				currentdict
				end % working temp dict
				Board 3 1 roll put

			}ifelse
			
	}


/$EndTRACK {

	
		grestore
	exit
}

>> def

/commandsZone << % >

/ZInfo {tf 72 string readline pop pop}%0 23 "GND"

/ZLayer {%15
	tf token {/zoneLayer exch def} if
}

/ZAux {
	tf token {/segments exch def} if %14 E
	tf token {/fillHatch exch def} if 
}

/ZClearance {tf 72 string readline pop pop} %0 T
/ZMinThickness {tf 72 string readline pop pop}%120
/ZOptions {tf 72 string readline pop pop}%0 16 F 200 200
/ZSmoothing {tf 72 string readline pop pop}%0 0

/ZCorner {
	/segmentCount segmentCount 1 add def
	%x y endflag
	
	segmentCount 
	[
		tf token {10 div}if
		tf token {10 div}if
		localMatrix itransform 
	
	] def
	tf token {/lastToken exch def }if



	lastToken 1 eq {
		segments segmentCount gt {
			% create a new zone for keepout (cutout) area
		    % inherit parameters
	zoneLayer 21 eq {
(silk zone1: ) = 
currentdict dfa
(-----------------) =
	}if

		    zoneLayer
		    
		    segments segmentCount sub
			/segments segmentCount def
			% close this dict
			11 NewLink	
			self
			currentdict
%(closing old zone ) =
%currentdict dfa
%(--------------) =
			end % working temp dict
			Board 3 1 roll put

%(opening new zone for keepout \(cutout\)) =
			/localZone 10 dict def 
		
			localZone begin  % working temp dict
		
			/linkCount 0 def  % modules are linked lists which are a forward reference
			/segmentCount 0 def
			/segments exch def
			/zoneLayer exch def
		
			Board /drawMatrix get /localMatrix exch def
		
			/keepout 2 def

		}if

	} if


}%77750 53855 0

/$POLYSCORNERS
{
	
	%(ZonePoly: ) =
	{
	tf 72 string readline {
		($endPOLYSCORNERS) anchorsearch {
			pop pop exit
		}{
			pop
		}ifelse
	}{/eof true def exit }  ifelse
	} loop
			
}

/$endCZONE_OUTLINE {

	zoneLayer 21 eq {
(silk zone: ) = 
currentdict dfa
(-----------------) =
gsave
%localMatrix  concat
1 1 1 setrgbcolor
		% convert to outline

		[
		[
		currentdict 1 get %cvx exec moveto
		currentdict 2 get 
		]
		3 2 segments  { /i exch def
		[
			currentdict i 1 sub get %cvx exec %lineto
			currentdict i get %cvx exec %lineto
		]
		[
			currentdict i get %cvx exec %lineto		
			currentdict i 1 add get %cvx exec %lineto
		]
		
		}for
		[
		currentdict i 1 add get %cvx exec %lineto
		currentdict 1 get %cvx exec moveto
		]
		
		]
		end   % this is the old zone dict, which is no longer valid
		{
			10 dict begin
			% open a new segment dict
			/lineThickness 10 def
lineThickness setlinewidth
			dup 0 get cvx exec /y1 exch def /x1 exch def
			1 get cvx exec /y2 exch def /x2 exch def
x1 y1 moveto x2 y2 lineto stroke
			9 NewLink 
			self
			currentdict
			end % working temp dict
			Board 3 1 roll put

		}forall
		%stroke
grestore
	}{
	
		11 NewLink
		
		self
		currentdict
		end % working temp dict
		Board 3 1 roll put
	}ifelse
%	(zone defined: ) print dfa
	/tabs tabs 1 sub def
	exit

} 
dup /$EndCZONE_OUTLINE exch


>> def

/descriptions << % >
	/GENERAL {
		{
			(*) print
			tf token {
		
				dup /$EndGENERAL eq {
					pop 
					verbose {
						(\n$General: ) =
						parametersGeneral dfa
						(\n) print
					} if
					exit
				} if
		
				dup /Di eq {
					[
					(Di ) print
					4 {
						tf token {
						10 div
						}if  % check for fatal error if there are not 4 bounds of the box here
					}repeat
					%(-> ) print pstack (<-) = flush 
					]
				}{
					dup /EnabledLayers eq {
						tf 4 string readhexstring {
						Long$ 1 3 -1 roll putinterval 
						%(-> ) print pstack (<-) = flush
						Long$ cvx exec
						}{ 0 }ifelse
					}{
						% parse the parameter		
						tf token {}{/notdef} ifelse
					}ifelse
				}ifelse
				
				parametersGeneral 3 1 roll put
				
			}{/eof true def exit }  ifelse 
		
		}loop
		(\n) print
	}
	

	/SETUP {
		% parse the setup section to get the default parameters for the file header
	
		verbose {
			($Setup: ) =
			parametersSetup dfa
			(\n) print
		}if 
		{
			tf token {
		
				dup /$EndSETUP eq {
					pop 
					verbose {
						(/$Setup: ) =
						parametersSetup dfa
						(\n) print
					} if
					
					parametersGeneral begin
					
					Di 0 2 getinterval cvx exec
					matrix translate /drawMatrix exch def
					Board /drawMatrix drawMatrix put
					
					10 dict begin
					%code: 2 id: 1 group: 0 link: 0
					
					2 NewLink
																	
					/P1 1 def % undefined parameter
					/P2 0 def
					
					Di 0 2 getinterval cvx exec drawMatrix itransform 
					cvi /y1 exch def
					cvi /x1 exch def
			
					/attributes -1 def
					/from 4 def
					/to 2 def
			
					self
					currentdict 
					end
					
					Board 3 1 roll put	% board linked list reference


					10 dict begin
					
					2 NewLink
											 
					/P1 1 def % undefined parameter
					/P2 0 def
					
					Di 2 get Di 1 get  drawMatrix itransform 
					cvi /y1 exch def
					cvi /x1 exch def
			
					/attributes 0 def
					/from 1 def
					/to 3 def
			
					self
					currentdict 
					end
					
					Board 3 1 roll put	% board linked list reference
			
					10 dict begin
					
					2 NewLink
											 
					/P1 1 def % undefined parameter
					/P2 0 def
					
					Di 2 2 getinterval cvx exec drawMatrix itransform 
					cvi /y1 exch def
					cvi /x1 exch def
			
					/attributes 0 def
					/from 2 def
					/to 4 def
			
					self
					currentdict 
					end
					
					Board 3 1 roll put	% board linked list reference
			
					10 dict begin
					
					2 NewLink
											 
					/P1 1 def % undefined parameter
					/P2 0 def
					
					Di 0 get Di 3 get drawMatrix itransform 
					cvi /y1 exch def
					cvi /x1 exch def
			
					/attributes 0 def
					/from 3 def
					/to 1 def
			
					self
					currentdict 
					end
					
					Board 3 1 roll put	% board linked list reference

					exit
				} if
				
				dup /Layer eq {
					(dynamic non default layer map: ) print
					tf 72 string readline {==}if  pop
					
				}{
					dup /InternalUnit eq {
						tf 72 string readline {==}if  pop
						% fixed at 10000
					}{
						dup /PcbPlotParams eq {
							tf token {pop} if pop % ignore the big string
						}{
							dup /TrackWidthHistory eq {
								tf 72 string readline readline {==}if  pop
								% this is mostly used as a pop up menu
								% e2k may want to save this info
							}{
								% these are two parameter attributes
								dup /TextPcbSize eq
								1 index /TextModSize eq
								2 index /PadSize eq 
								3 index /AuxiliaryAxisOrg eq
								or or or {
									[
									2 {
										tf token {} if
									} repeat
									]
									
									parametersSetup 3 1 roll put
								}{
									% the bulk of the attributes are
									% single integer parameters
									tf token {} if
									parametersSetup 3 1 roll put
								}ifelse
							}ifelse
						}ifelse
					}ifelse
				}ifelse				
			}{/eof true def exit }  ifelse 
		
		}loop
				
	}
	
	/SHEETDESCR	 {						
		{
			tf 72 string readline {
		 
				($End) anchorsearch {
					/tabs tabs 1 sub def
					verbose {
						tabs {( ) print} repeat
						pop (end section: ) print == flush % section name
					}{pop pop}ifelse	
					exit
				 }{
					pop %==
				}ifelse 
		 
			}{/eof true def exit }  ifelse 
	
		}loop
	}
	dup /NCLASS exch
	dup /SHAPE3D exch

	/PAD {
	
		/linkCount linkCount 1 add def
	
		linkCount
		10 dict begin
		/linkCount exch def % use this for pin number when pin number is text
		
		3 NewLink
		%(new pad: ) print self =string cvs print
		
		% update the local linked list
		linkCount 1 eq {
			localModule /firstLink self put
			%(pad root: ) print self ==

		}{
			% simple method without search links are added in order
			% to the prior reference
			self
			Board self 1 sub get begin
			/next exch def
		%( n: ) print next =string cvs print
			end
		
		}ifelse
		
		%( lC: )print linkCount ==
		
		{
			tf token {
		 			
					commandsPad exch 2 copy known {
						get exec
					}{
						% catch the Text comment fields
						
						(bad pad token: ) print ==
						pop 
						
		 			} ifelse
		 			
			}{/eof true def exit }  ifelse 
	
		}loop
	
	}
		
	/MODULE		
	{						
		tf 72 string readline {
			
			verbose {
				(module library reference: ) print == flush
			}{pop}ifelse
			
			/localModule 10 dict def 
			
			localModule begin  % working temp dict
			
			/linkCount 0 def  % modules are linked lists which are a forward reference
			/segmentCount 0 def
			/padCount 0 def
			
			Board /drawMatrix get /localMatrix exch def
			
			gsave
			
		}{/eof true def exit }  ifelse 

		{
			tf token {
					/command exch def
		 
					commandsModule /command load 2 copy known {
						get exec
					}{
						% catch the Text comment fields
						
						(bad module token: ) print ==
						pop 
		 			} ifelse
			}{/eof true def exit }  ifelse 
	
		}loop

	}

	/DRAWSEGMENT {	
	
	% lines == 2 circles 1 | 3 arcs == 2
	%$DRAWSEGMENT
	%Po <shape> <Xstart> <Ystart> <Xend> <Yend> <width>
	%De <layer> <type> <angle> <timestamp> <status>
	%$EndDRAWSEGMENT

						
		/localText 10 dict def 
		
		localText begin  % working temp dict
			
		Board /drawMatrix get /localMatrix exch def


		{
			tf token {
					/command exch def
		 
					commandsDraw /command load 2 copy known {
						get exec
					}{
						% catch the Text comment fields
						
						(bad draw token: ) print ==
						pop 
		 			} ifelse
			}{/eof true def exit }  ifelse 
	
		}loop
%tfn ==
%showpage
%ddbugdraw

	}

	/TEXTPCB {	
	
	% static text 
	%$TEXTPCB
	%Te "<string>" -- with quotes
	%Po <Xstart> <Ystart> <Xsize> <Ysize> <Width> <rotation>
	%De <layer> < 1 == normal | 0 == mirrored> timestamp <Normal | italic>
	%$EndTEXTPCB	
	
verbose {
	(text parse: ) = %print == flush
}{}ifelse
		
		/localText 10 dict def 
		
		localText begin  % working temp dict
			
		Board /drawMatrix get /localMatrix exch def


		{
			tf token {
					/command exch def
		 
					commandsText /command load 2 copy known {
						get exec
					}{
						% catch the Text comment fields
						
						(bad text token: ) print ==
						pop 
		 			} ifelse
			}{/eof true def exit }  ifelse 
	
		}loop

	}
	
	% tracks and vias


	/TRACK {	
	
	% static text 
	%$TRACK
	%Po <shape> <Xstart> <Ystart> <Xend> <Yend> <Width> <drill>
	%De <layer> < 1 == via | 0 == track> timestamp <status>
	%$EndTRACK	
	
	% shapes are 0 track, 1 burried, 2 blind, 3 through
	% only through vias are supported
	
	% traces are only supported on the top and bottom layer
			
			verbose  {
				(track structure: ) = %print == flush
			}{}ifelse
			
			
			gsave
			

		{
			tf token {
					/command exch def
		 
					commandsTrack /command load 2 copy known {
						get exec
					}{
						% catch the Text comment fields
						
						(bad track token: ) print ==
						pop 
		 			} ifelse
			}{/eof true def exit }  ifelse 
	
		}loop
	}

	/CZONE_OUTLINE
	{						
			
			
		/localZone 10 dict def 
		
		localZone begin  % working temp dict
		
		/linkCount 0 def  % modules are linked lists which are a forward reference
		/segmentCount 0 def
		
		Board /drawMatrix get /localMatrix exch def
		
		/keepout 1 def
			

		{
			tf token {
					/command exch def
		 
		 			%(parse: ) print /command load ==
		 
					commandsZone /command load 2 copy known {
						get exec
					}{
						% catch the Text comment fields
						
						(bad zone token: ) print ==
						pop 
		 			} ifelse
			}{/eof true def exit }  ifelse 
	
		}loop
	


	}
	
	/EndBOARD { %(leak: ) print count ==	
	exit} 
	
	/EQUIPOT {
		netNames begin
		/netTableLength netTableLength 1 add def
		end
		{
			tf token {
				/command exch def
		 
				%(parse: ) print /command load ==
	 
				<< % >
				/Na {
					netNames tf token {
						quoteText put
					}if 
				}
				/St {tf 72 string readline {pop}if }
				/$EndEQUIPOT {/tabs tabs 1 sub def exit}
				
				>> /command load 2 copy known {
					get exec
				}{
					% catch the Text comment fields
					
					(bad net definition \(EQUIPOT\) token: ) print ==
					pop 
				} ifelse
			}{/eof true def exit }  ifelse 
	
		}loop
	
	}

>> def


/print_pcbfile {

	writefiles {
		wf exch writestring
	}{
		(\033[0;34m<) print $ print (\033[0m) =
	}ifelse
} bind def


/writeBack << % >
% block info
% most blocks are components
% groups can be titleblocks
1 {
	verbose {
	%currentdict dfa
	 (\033[1;35mnmodule\033[0m) = 
	(footprint: 4) =
	( root link: ) print firstLink ==
	(ref: ) print T0 /fText get =
	(value: ) print %T1 /fText get =
	currentdict /Cd known {
		Cd
	}{
		Li	% library is alway required
	}ifelse =

	T0 begin

attrib_text qdbp 
% split it out
dup 0 12 getinterval print ( ) print
dup 12 1 getinterval print ( ) print
%dup 13 1 getinterval print ( ) print
13 3 getinterval print (b TextAttributes) =

(backcheck attributes: font size: ) print		
attrib_text -4 bitshift =string cvs print ( direction index: ) print
attrib_text 16#07 and =string cvs print ( v: ) print
attrib_text 16#08 and ==
	
(backcheck rotation: ) print	
[ 0 90 180 270 ] attrib_text 16#07 and get ==
	
	%/attrib_style 1 def		% fixed style
	%(attrib_style: ) print 1 ==

	(center X: ) print xc ==
	(center Y: ) print yc ==
	
	(posX: ) print x1 ==
	(posY: ) print y1 ==

	end
	
	(position1: ) print 0 ==
	(position2: ) print 0 ==

} if
%	key1: type (title block, component, symbol, footprint)
		key1_type 1 putItem print_pcbfile

%	key3: link root
		firstLink 3 putItem print_pcbfile

%	varstring key2: part name name (value)
		%T1 /fText get -- value is in the netlist
		% this is really the part description comment
		currentdict /Cd known {
			Cd
		}{
			Li	% library is alway required
		}ifelse 
		
		dup length 2 putItem print_pcbfile
		{2 putItem  print_pcbfile}forall

%	varstring key2: reference
		T0 /fText get dup length 2 putItem  print_pcbfile
		{2 putItem  print_pcbfile}forall

%	key2: textAttributes
		T0 begin

		attrib_text 2 putItem print_pcbfile

%	key3: ref positionX
%	key3: ref positionY
		
		x1 3 putItem print_pcbfile
		y1 3 putItem print_pcbfile
		
%	key2: value position1
%	key2: value position2
		0 2 putItem print_pcbfile
		0 2 putItem print_pcbfile
		
		end

render {
T0 begin
gsave
	
	DisplayFont %attrib_size 1.3 mul selectfont % rotate text context
	findfont 
	%[Yscale  0 0 2 index neg 0 4 index] 
	[Xscale 0 0 Yscale neg 0 Yscale]
	fieldAngle neg matrix rotate
	matrix concatmatrix
	%TX_DIRECTION  attrib_dir get matrix concatmatrix
	makefont setfont

				
	0 .3 .9 setrgbcolor
	penWidth setlinewidth
		
	-25 0 textMatrix transform moveto 25 0 textMatrix transform  lineto stroke
	0 -25 textMatrix transform moveto 0 25 textMatrix transform  lineto stroke
	

	/fVis load  /V eq {
	1 1 1 setrgbcolor
	
	0 0 textMatrix transform moveto
	%0 0 moveto 
	fText show
	}if
grestore
end
}if

}

% Board outline 
% represents edges of board
2 {				

verbose {
	 (\033[1;35mOutline\033[0m) = 
	(P1: ) print P1 ==
	(P2: ) print P2 ==
	(x1: ) print x1 ==
	(y1: ) print y1 ==
	(attributes: ) print attributes ==
	(from: ) print from ==
	(to: ) print to ==
} if

	P1 1 putItem print_pcbfile
	P2 3 putItem print_pcbfile
	x1 3 putItem print_pcbfile
	y1 3 putItem print_pcbfile
	attributes 2 putItem print_pcbfile
	from 3 putItem print_pcbfile
	to 3 putItem print_pcbfile
}

% Pad
3 {
verbose {
	(\033[1;35mPad\033[0m) = 
	%currentdict dfa (\n) print

	(Attributes: <) print var_2C 2 putItem =$

	/var_48 var_2C -6 bitshift def
	(var_48 -- layer options: ) print var_48 == % something to do with layers

	/var_34 var_2C -4 bitshift 3 and def
	(var_34 -- pad rotation: ) print var_34 ==  % pad rotation ? 

	/var_1C var_2C 16#0F and def				% leaves pad shape as a default
	(var_1C  -- pad shape: aperture? ) print var_1C ==

	(pad size: [) print 
	padWidth cvi =string cvs print
	( ) print padHeight cvi  =string cvs print (])=

	(drill index: ) print 
	padDrill 0 eq {
		0
	}{
		revMapdrill padDrillIdx get
	}ifelse
	==

	(pad center: [) print 
	x1 cvi =string cvs print
	( ) print y1 cvi =string cvs print (])=

	(pin number: ) print padIDNum ==

	(net info: ) print netTxt print ( ) print netIdx ==

	(interconnect: ) print 0 ==  % interconnect requires zone netlist

}if
%			(version 6 and above)
%			key2: Attributes
%				layer options 
%					100: both layers
%					2: silk
%					10: component
%					20: copper
%				pad rotation 
%					1:0 2:90 3:180 4:270
%				pad shape
%					1 via
%					2 round
%					3 square
%					4 rectangle
%					5 bga	
	var_2C 2 putItem print_pcbfile
%			key2: padWidth
	padWidth  2 putItem print_pcbfile
%			key2: padHeight
	padHeight 2 putItem print_pcbfile

%			key2: drill index (table of 24 drill sizes)
	padDrill 0 eq {
		0
	}{
		revMapdrill padDrillIdx get
	}ifelse
	2 putItem print_pcbfile

%			key3: X1
%			key3: Y1
	x1 3 putItem print_pcbfile
	y1 3 putItem print_pcbfile
	
%			key2: pin number
	padIDNum 2 putItem print_pcbfile

%			key1: layer interconnect attributes
	0 1 putItem print_pcbfile
%				zone forward reference

	


}

% edge or corner
4 {
verbose {
	(\033[1;35mcorner: ) print self ==
	(\033[0m) =
	currentdict dfa
	 
} if
	% corner object point coordinates
	% non pad or via trace connection
	% traces in expressPCB are global and do not contain net information

	%	key3: positionX
	%	key3: positionY
	x1 3 putItem print_pcbfile
	y1 3 putItem print_pcbfile
	%	key1: layer number
	padLayers 1 putItem print_pcbfile
	
}

% trace
5 {		 
verbose {			
	(\033[1;35mtrace: ) print self ==		
	(\033[0m) =
	(lineWidth \(table index\): ) print traceIdx ==
	(layer: ) print padLayers ==
	(attributes: -1) =
	(from:) print from ==
	(to:) print to ==
	(____) ==
}if

% Trace object connects to corners or edges
% netlist can be infered from these connections
	%	key1: lineWidth (table index)
	traceIdx 1 putItem print_pcbfile

	%	key1: layer
	padLayers 1 putItem print_pcbfile

	%	key2: attributes (version 5 and above)
	-1 2 putItem print_pcbfile

	%	key3: from
	%	key3: to
	from 3 putItem print_pcbfile
	to 3 putItem print_pcbfile
		

render {

		padLayers 2 eq {
			1 .7 .2 setrgbcolor
		}if 

		gsave
		padLayers 10 eq {
			233 255 div 150 255 div 122 255 div setrgbcolor
		}if
		
		padLayers 20 eq {
			123 255 div 104 255 div 238 255 div setrgbcolor
		}if 
		
		padLayers 100 eq {
			1 0 0 setrgbcolor
		 
		} if
		
		LineWidthMap traceIdx get setlinewidth
		
		Board from get begin
		x1 y1 moveto
		end
		
		Board to get begin
		x1 y1 lineto
		end

		stroke
		grestore
} if

%currentdict dfa		

}

6 {		% unknown -- does not seem to exist
}

% pcb text
7 {
verbose {			
	(\033[1;35mPCB text: \033[0m) =
	attrib_text qdbp 
	% split it out
	dup 0 12 getinterval print ( ) print
	dup 12 1 getinterval print ( ) print
	%dup 13 1 getinterval print ( ) print
	13 3 getinterval print (b TextAttributes) =

	(backcheck attributes: font size: ) print		
	attrib_text -4 bitshift =string cvs print ( direction index: ) print
	attrib_text 16#07 and =string cvs print ( v: ) print
	attrib_text 16#08 and ==
	
	(backcheck rotation: ) print	
	[ 0 90 180 270 ] attrib_text 16#07 and get ==

%	currentdict dfa
%	(---) =
}if
% static text may be on any layer
% text on back/copper layer is mirrored
	%	key1: lineWidth (table index)
%	varstring key2: text
	staticText length 2 putItem print_pcbfile
	staticText {
		2 putItem print_pcbfile
	}forall
	
%	key1: layer
	this_layer 1 putItem print_pcbfile
%	key2: attribute direction
	attrib_text 2 putItem print_pcbfile
%	key1: attributes style
	1 1 putItem print_pcbfile
%	key3: positionX
%	key3: positionY
	x1 3 putItem print_pcbfile
	y1 3 putItem print_pcbfile

render {
	gsave
	newpath
	.9 .7 0 setrgbcolor
	penWidth setlinewidth
	
	
	x1 25 sub y1 moveto x1 25 add y1 lineto stroke
	x1 y1 25 sub moveto x1 y1 25 add lineto stroke


	DisplayFont %attrib_size 1.3 mul selectfont % rotate text context
	findfont 
	%[Yscale  0 0 2 index neg 0 4 index] 
	[Xscale 0 0 Yscale neg 0 Yscale]
	textRotation neg matrix rotate
	matrix concatmatrix
	%TX_DIRECTION  attrib_dir get matrix concatmatrix
	makefont setfont



	this_layer 2 eq {
		1 .7 .2 setrgbcolor
	}if 

	gsave
	this_layer 10 eq {
		233 255 div 150 255 div 122 255 div setrgbcolor
	}if
	
	this_layer 20 eq {
		123 255 div 104 255 div 238 255 div setrgbcolor
	}if 
	
	this_layer 100 eq {
		1 0 0 setrgbcolor
	 
	} if

	x1 y1 moveto staticText show
	grestore
}if

}

% filled rectangle
8 {
		% filled rectangle - not pads
		% may not be a kiCad equivelent
}

% line drawing
9 {		
	% non trace line. This is used for silk screen drawings
verbose {			
	(\033[1;35mline draw: \033[0m) =
}if
	% must be layer
	%read1 (layer: )
	% always layer 2 
	2 1 putItem print_pcbfile			

	% start and end points
	%read3 (x1: )
	%read3 (y1: )
	x1 3 putItem print_pcbfile			
	y1 3 putItem print_pcbfile			

	%read3 (x2: )
	%read3 (y2: )

	x2 3 putItem print_pcbfile			
	y2 3 putItem print_pcbfile			

	% thickness
	%read3 (t: )
	lineThickness 3 putItem print_pcbfile
	
	
	render {
		gsave

		1 255 215 div 0 setrgbcolor		
	
		lineThickness setlinewidth
		x1 y1 moveto

		x2 y2 lineto stroke

		grestore
	}if

}

% circle
10 {
	% circle arc object
	% express can only draw a small group of arcs that are rotated
	%	10: arc
%shape ==
%arcrotation ==
	/arcattrib shape 16#07 and arcrotation  5 bitshift 16#E0 and or def

verbose {			
	(\033[1;35mcircle or arc draw: \033[0m) =
	(key1: attributes: ) print arcattrib dup =string cvs print ( ) print qdbp ==
	(key3: positionX: ) print x1 ==
	(key3: positionY: ) print y1 == 
	(key3: radius: ) print radius ==
	(key3: linewith: ) print lineThickness ==
	(key1: layer: ) print layerMap lineLayer get ==
} if
		
	

	%key1: attributes: 
	arcattrib 1 putItem print_pcbfile			

	%key3: positionX:
	%key3: positionY: 
	x1 3 putItem print_pcbfile			
	y1 3 putItem print_pcbfile			

	%key3: radius: 
	radius 3 putItem print_pcbfile			

	%key3: linewith: 
	lineThickness 3 putItem print_pcbfile			
	
	%key1: layer: 
	layerMap lineLayer get  1 putItem print_pcbfile			
	
render {
	gsave
	lineThickness setlinewidth

	x1 y1 radius 
	K_ARC_DIRECTION arcrotation 1 sub get shape 1 sub get {} forall
	arc stroke
	grestore
}if
%verbose { (-----------) = } if 
%	currentdict dfa

}

% Zone
11 {	%(zone defined: ) print currentdict dfa
verbose {			
	(\033[1;35mzone defined: \033[0m) =
} if
	%read1 (zone attributes: )
	keepout  1 putItem print_pcbfile	
	
	%read1 layer
	layerMap zoneLayer get 1 putItem print_pcbfile	
	
	%read2 segment count
	segments 2 putItem print_pcbfile	

	1 1 segments {
		currentdict exch get cvx exec exch
	%read3 xp 
	%read3 yp
		3 putItem print_pcbfile
		3 putItem print_pcbfile
	}for
		
%currentdict dfa
%(+++-----+++) =	
		
	render {
		%(zone layer: ) print layerMap zoneLayer get ==
		
		/lz layerMap zoneLayer get def

		% zone layer 2 is not supported (does not seem to cause an error though)
		lz 2 eq {
			1 .7 .2 setrgbcolor
		}if 
		
		lz 15 eq {
			233 255 div 150 255 div 122 255 div setrgbcolor
		}if
		
		lz 20 eq {
			123 255 div 104 255 div 238 255 div setrgbcolor
		}if 
		
		keepout 2 eq {
			1 0 0 setrgbcolor
		 
		} if
		
		%(points in plane: ) print segments == 

		gsave
		[65] 0 setdash
	 
		newpath
		
		currentdict 1 get cvx exec moveto

		2 1 segments {
			currentdict exch get cvx exec lineto
		
		}for
		
		closepath
		stroke
		grestore
	} if
		
		% end


}



>> def

/fieldParameters { 
%T<field number> <Xpos> <Ypos> <Xsize> <Ysize> <rotation> <penWidth> N <visible> <layer> "text"
	%/command load 24 string cvs ==
	
	10 dict begin
	tf token { 10 div /Xstart exch def} if
	tf token { 10 div /Ystart exch def} if
	
	Xstart Ystart moduleMatrix itransform 
	/yc exch def /xc exch def

	tf token { 10 div /Xsize exch def} if
	tf token { 10 div /Ysize exch def} if

	tf token { 10 div /textRotation exch def} if
	tf token { 10 div /penWidth exch def} if

	tf token { pop} if

	tf token { /fVis exch def} if

	tf token { /textLayer exch def} if

	tf token { pop} if

	quoteText /fText exch def
	
	
	0 1 textSizeFilter length 2 sub {
		/textSizeLimit exch def
		
		Ysize 38 lt {/textSizeLimit textSizeLimit 1 sub def exit} if
		
		Ysize textSizeFilter textSizeLimit get gt 
		Ysize textSizeFilter textSizeLimit 1 add get le 
		and {exit}if
		
	}for
	/Ysize textSizeFilter textSizeLimit 1 add get def

verbose  {
	(filtered text size: ) print Ysize ==
}if
	%Virtual space for scaling font
	gsave
	newpath
	DisplayFont findfont Ysize scalefont setfont
	0 0 moveto (M) true charpath pathbbox
	3 -1 roll sub 
	Ysize exch div Ysize mul /Yscale exch def 
	exch sub Xsize exch div Xsize mul 
	/Xscale exch def

	% define center first this is the default
	/textOffset 
	%staticText true charpath pathbbox 
	%pop exch pop sub 2 div 
	textLayer 20 eq { 
		%mirror text on back layer
		% we do not have a back silk layer
		% so this is informational 
		fText length Xsize mul 2 div
	}{
		fText length Xsize mul 2 div neg
	}ifelse
	def

	% for some reason rotating -90 
	% with +- 90 rotated text mirrors 
	% the text startpoint
	angle cvi 270 eq 
	textRotation cvi 270 eq  and
	angle cvi 90 eq 
	textRotation cvi 90 eq and
	or  {
		/textOffset textOffset neg def
	}if

	grestore
	% end of virtual space


	% text rotation is limited to horizontal or vertical

	% horizontal or vertical
	/fieldAngle textRotation  def  
	
	{
		/fieldAngle fieldAngle 180 sub  def  
		fieldAngle 0 le {exit} if
	} loop
	fieldAngle 0 lt {/fieldAngle fieldAngle 180 add def} if

verbose not  {
fText ==
(part rotation angle: ) print angle ==
(text rotation angle: ) print textRotation ==
(field angle: ) print 	fieldAngle ==
}if
	revRotate fieldAngle cvi 2 copy known {
		get 1 add
	}{
		pop pop 1
	}ifelse
	/attrib_dir exch def
	
	/attrib_vis 0 def
	/fVis load  /V eq textLayer 21 eq and {
		/attrib_vis 16#08 def 
	}if
	
	/attrib_text 
		attrib_vis 
		attrib_dir 16#07 and or
		Ysize cvi 4 bitshift 
		or
	def 

verbose  {
attrib_text qdbp 
% split it out
dup 0 12 getinterval print ( ) print
dup 12 1 getinterval print ( ) print
%dup 13 1 getinterval print ( ) print
13 3 getinterval print (b TextAttributes) =

(backcheck attributes: ) print		
attrib_text -4 bitshift =string cvs print ( ) print
attrib_text 16#07 and =string cvs print ( ) print 
attrib_text 16#08 and ==

} if


	fieldAngle matrix rotate % file rotation

	xc yc matrix translate 
			
	matrix concatmatrix
	
	fieldAngle cvi abs 90 eq
	fieldAngle cvi abs 270 eq or {
		Ysize 2 div neg textOffset matrix translate
	}{
		fieldAngle cvi abs 0 eq
		fieldAngle cvi abs 180 eq or 
		fieldAngle cvi abs 360 eq or {
			textOffset Ysize 2 div neg matrix translate
		}{
			matrix
		}ifelse
	}ifelse
	
	matrix concatmatrix /textMatrix exch def

	0 0 textMatrix transform /y1 exch def /x1 exch def

verbose {
currentdict dfa
(---) =
	 	
(textMatrix: ) print  textMatrix ==
(\n) print
} if
render {
gsave
	
	DisplayFont %attrib_size 1.3 mul selectfont % rotate text context
	findfont 
	%[Yscale  0 0 2 index neg 0 4 index] 
	[Xscale 0 0 Yscale neg 0 Yscale]
	fieldAngle neg matrix rotate
	matrix concatmatrix
	%TX_DIRECTION  attrib_dir get matrix concatmatrix
	makefont setfont

verbose  {currentfont /FontBBox get ==} if
				
	0 .3 .9 setrgbcolor
	penWidth setlinewidth
	
	xc 50 sub yc moveto xc 50 add yc lineto stroke
	xc yc 50 sub moveto xc yc 50 add lineto stroke

{
	gsave
	%x1 y1 translate % file translation
	0 0 textMatrix transform translate

	fText =$
			
	/Xpoint 0 def 
	fText {
	(!) print
		Xpoint Ysize 2 div neg moveto ( ) dup 0 4 -1 roll put show
		Xpoint 0  Xsize Ysize rectstroke
		/Xpoint Xpoint Xsize add def
	} forall
	grestore	
} pop
	.9 .7 0 setrgbcolor
	penWidth setlinewidth
	
	
	-25 0 textMatrix transform moveto 25 0 textMatrix transform  lineto stroke
	0 -25 textMatrix transform moveto 0 25 textMatrix transform  lineto stroke
	
	/fVis load  /V eq {
	1 1 1 setrgbcolor
	
	0 0 textMatrix transform moveto
	%0 0 moveto 
	fText show
	}if

grestore
}if 
	
	currentdict end
%tfn ==
%showpage
%ddbugdraw

	
	/command load exch def

} bind def

tfd 
{

	cleardictstack % prevent leaky dicts
%	(leakydicts: ) print countdictstack ==

	/tfn exch def
	verbose {(processing: ) print tfn ==}if
	/tf tfn (r) file def 

	/fatalError false def

	/suffix tfn length def
	[ 47 46 tfn {}forall 
	{46 eq {exit}{/suffix suffix 1 sub def }ifelse} loop 
	/filenamepos suffix 1 sub def
	{47 eq {exit}{/filenamepos filenamepos 1 sub def }ifelse} loop 
	] makestring (/.) anchorsearch {pop} if

	/PathPrefix exch def

	tfn filenamepos suffix filenamepos sub 1 sub getinterval /SubFilename exch def

	(infile path prefix: ) print PathPrefix ==
	(infile: ) print SubFilename ==
	
	
	KiCadDataFolderPfx  SubFilename strcat /NewProjectPfx exch def 

	NewProjectPfx (_e.pcb) strcat
	/NewBoardName exch def
	
	/Board 10 dict def
	
	/netNames 10 dict def  % from EQUIPOT
	
	netNames begin
	/netTableLength 0 def 
	end 

	/partIDs 10 dict def  % from EQUIPOT
	
	partIDs begin
	/partIDsTableLength 0 def 
	end 

	/EdgeReverse 10 dict def % pads and via lookups
	
	/CornerReverse 10 dict def % corner lookups

	NewProjectPfx (_e.net) strcat
	/NewNetlistName exch def

NewBoardName ==

/ddbugdraw {
	% fill background with black -- traditional for board editing 
	render {
	
		0 0 0 setrgbcolor
		
		0 0 612 792 rectfill


		%306 384 translate  180 rotate
		%36 700 translate 180 rotate
		270 rotate
%		72 300 div dup scale
		72 500 div dup scale 			% view with 150% enlargement 
		%72 1000 div dup scale 			% normal scale
		-1 1 scale
		
			
		0 1 1 setrgbcolor
	
		12 setlinewidth
		
		1 setlinecap
		
		1 setlinejoin
	
			
	} if
} bind def


	/eof false def
% parse the file

	/tabs 0 def

showpage
ddbugdraw	

(parsing: ) =	
	tf 72 string readline { == } if  % first line should be ident

	{
		tf read{ 
			36 eq {
				tf token {
					verbose {
						tabs {( ) print} repeat
						(section: /) print dup == flush % section name
					}if
					/tabs tabs 1 add def
					
					descriptions exch 2 copy known {
					%(->) print pstack (<-) = flush
						get exec
%(leak3: ) print count ==	
					}{
						pop pop
						{
							tf 1024 string readline {
						 
						 		($End) anchorsearch {
						 			/tabs tabs 1 sub def
									verbose {
						 				tabs {( ) print} repeat
						 				pop (end section: ) print == flush % section name
						 			}{pop pop} ifelse
						 			exit
								 }{
						 			pop %==

						 		}ifelse 
						 
						 	}{/eof true def exit }  ifelse 
%(leak3a: ) print count ==	
					
						}loop
					}ifelse
				}{/eof true def }  ifelse  	
			} if
		

		}{/eof true def exit }  ifelse   
	}loop
%(leak4: ) print count ==	
	
		

	tf flushfile
	tf closefile
(file parsed: ) =

/print_netlistFile {

	ddnetlist 1 gt {
		netfileref exch writestring
	}{
		ddnetlist 0 gt {print}{pop}ifelse
	}ifelse
} bind def


ddnetlist 1 eq {
tfn ==
showpage 
ddbugdraw
} if

ddnetlist 0 gt {NewNetlistName ==} if

NewNetlistName ddnetlist 1 gt { (w) file /netfileref exch def}{pop}ifelse


	% create a table based on net number that will
	% contain the part pin number info
	("ExpressPCB Netlist"\r\n) print_netlistFile
	("SwCAD III version 2.03r"\r\n) print_netlistFile
	(1\r\n) print_netlistFile
	(0\r\n) print_netlistFile
	(0\r\n) print_netlistFile
	(""\r\n) print_netlistFile 
	(""\r\n) print_netlistFile 
	(""\r\n) print_netlistFile 
	
	/netTable netNames /netTableLength get array def

	0 1 netTable length 1 sub {
		netTable exch 10 dict
		begin
			/thisLink 0 def
		currentdict 
		end		
		put
	} for


	("Part IDs Table"\r\n) print_netlistFile 
%"B1 "6v" "" 
%"R1 "330"  "" 
%"D1" "LED" "" 
	/netLinkIdx 1 def
	
	/tempDict currentdict def

	%partIDs dfa
	1 1 partIDs /partIDsTableLength get 1 sub {
		/partID exch def
		partIDs partID get 
%(found ID: ) print dup ==
		Board exch 2 copy known { 
		
		get begin

		(") print_netlistFile
		T0 /fText get 
		dup length 1 lt {pop (Ref***)} if		
		print_netlistFile
		(" ") print_netlistFile
		T1 /fText get 
		dup length 1 lt {pop (Val***)} if
		print_netlistFile
		(" ""\r\n) print_netlistFile

		/listLink firstLink def 
		
		% calculate the forward ref where the net starts within
		% the table. 
			
		{
			Board listLink 2 copy known {
				get begin
				
				%(s: ) print self =string cvs print
				%( c: ) print Object =string cvs print
				%( g: ) print group =string cvs print
				%( n: ) print next ==
				Object 3 eq {			
					%(pad number: ) print 
					
					%(net: ) print netTxt print ( ) print
					%netIdx ==
					netTable netIdx get begin 
					/thisLink thisLink 1 add def
					thisLink [netIdx partID padIDNum] def
					
					end
					
				} if
				next
				end
				/listLink exch def
				listLink 0 eq{exit} if
			}{
				(# Broken link: ) print == pop
				exit
			}ifelse
		} loop

		
		end
		}{
			(# Missing ID: ) print == pop
		}ifelse
	} for



	(\r\n"Net Names Table"\r\n) print_netlistFile
%"N0001" 1 
%"Gnd" 3 
%"N0002" 5 

	/NetConnectionsTable 10 dict def

	/netLinkIdx 1 def
	/netNumber 0 def
	netTable {
		/thisNetList exch def
		/netCount thisNetList /thisLink get def
		netNumber 0 ne {
			(") print_netlistFile
			netNames netNumber get print_netlistFile 
			(" ) print_netlistFile 
			netLinkIdx =string cvs print_netlistFile
			(\r\n) print_netlistFile
			1 1 netCount {
				/idx exch def
				() % empty string to add to
				thisNetList idx get
				%dup 0 get 0 ne {
				/netLinkIdx netLinkIdx 1 add def
				
				{12 string cvs  ( ) strcat strcat} forall
				idx 1 add netCount le { 
					netLinkIdx 12 string cvs  <0D0A> strcat strcat 
				}{
					<300D0A> strcat
				}ifelse
				NetConnectionsTable netLinkIdx 1 sub 3 -1 roll put
				%}{pop}ifelse 
			} for
		}if
		/netNumber netNumber 1 add def
	
	} forall 

	(\r\n"Net Connections Table"\r\n) print_netlistFile
%1 1 1 2 
%1 2 1 0 
%2 1 2 4 
%2 3 1 0 
%3 3 2 6 
%3 2 2 0	NetConnectionsTable 
	1 1 NetConnectionsTable length {
		NetConnectionsTable exch get print_netlistFile 
	} for

ddnetlist 1 gt {netfileref closefile} if

tfn ==
showpage 
ddbugdraw



(detailing board) =

	% where is the best place to write the header
	writefiles {	
		% this point has most of the header information
		/wf NewBoardName (w) file def

		%(\nheader <) print
		wf <C7B930010700000002000E00> writestring
		
		%(key <) print  =$ % key goes here
		wf <0000> writestring
		
		%(undefined <) print 
		wf <000000 000000> writestring
	
		parametersSetup begin
	
		%(layers: <) print 
		Layers 2 putItem print_pcbfile
	
		%(TrackClearence: <) print 
		TrackClearence 10 div cvi 2 putItem print_pcbfile
		
		%(ZoneClearence: <) print 
		ZoneClearence 10 div cvi 2 putItem print_pcbfile
	
		%(default via: <) print 
		ViaSize 10 div cvi 2 putItem print_pcbfile
	
		%(default via drill #index: <) print	
		
		350 2 putItem print_pcbfile
		
		%(undefined: <) print 
		wf <0000> writestring
		
		%(schematic link name: ) print 
		0 2 putItem print_pcbfile
	
		%(22 key2: undefined bytes: ) =
		
		3 2 putItem print_pcbfile
		
		7{0 2 putItem print_pcbfile}repeat
		8{-1 2 putItem print_pcbfile}repeat
		6{0 2 putItem print_pcbfile}repeat
	
		end
		wf flushfile

	}{
		(\033[0;34m) print
		% this point has most of the header information
		(Boaard filename: ) print NewBoardName print

		(\nheader <) print
		<C7B930010700000002000E00> =$
		
		(key <) print  % key goes here
		 <0000> =$
		
		(undefined <) print 
		 <000000 000000> =$
	
		parametersSetup begin
	
		(layers: <) print 
		Layers 2 putItem  =$
	
		(TrackClearence: <) print 
		TrackClearence 10 div cvi 2 putItem  =$
		
		(ZoneClearence: <) print 
		ZoneClearence 10 div cvi 2 putItem =$
	
		(default via: <) print 
		ViaSize 10 div cvi 2 putItem  =$
	
		(default via drill #index: <) print	
		
		350 2 putItem  =$
		
		(undefined: <) print 
		 <0000> =$
		
		(schematic link name: ) print 
		0 2 putItem  =$
	
		(22 key2: undefined bytes: <) print
		
		3 2 putItem  =$
		
		7{(<) print 0 2 putItem  =$}repeat
		8{(<) print -1 2 putItem  =$}repeat
		6{(<) print 0 2 putItem  =$}repeat
	
		end
		(\033[0m) print

	
	}ifelse

	render {
		%	-3800 2 div -2500 2 div translate			% mini-board zero

		parametersGeneral begin

%		Di 0 2 getinterval {neg  2 div } forall translate  % move origin to center board in display

		-3000 0 moveto 3000 0 lineto stroke				% mark new origin
		0 -3000 moveto 0 3000 lineto stroke

		gsave
		Di 0 2 getinterval {neg} forall translate			% set upper left to the new origin
				
		1 255 215 div 0 setrgbcolor		
		
		Di 0 2 getinterval cvx exec moveto
		Di 2 get Di 1 get lineto
		Di 2 2 getinterval cvx exec lineto 
		Di 0 get Di 3 get lineto
		Di 0 2 getinterval cvx exec lineto
		stroke
		grestore
		
		end
	} if
	
	% dump the full list of references
	(self : object : group : next ) =
	1 1 linkParameters /refcount get {
		Board exch 2 copy known {		
		get begin
		writefiles {
			self 	3 putItem print_pcbfile
			Object	1 putItem print_pcbfile
			group 	3 putItem print_pcbfile
			next 	3 putItem print_pcbfile
		}if
		
		true {
			%(\n) print
			(s: ) print self =string cvs print
			( c: ) print Object =string cvs print
			( g: ) print group =string cvs print
			( n: ) print next ==
			%(\n) print
		}if
		
		writeBack Object get exec
		
		end
		}{
			(# Missing object ref in board: ) print == pop
		} ifelse
	} for 
	
	writefiles {
		wf closefile
	}if
	
	
	NewBoardName ==
	showpage

} 256 string filenameforall % for batch processing files

